// This file implements the IRemoteDebugApplication Interface and Gateway for Python.
// Generated by makegw.py

#include "stdafx.h"

#include "PyIRemoteDebugApplication.h"

// @doc - This file contains autoduck documentation
// ---------------------------------------------------
//
// Interface Implementation

PyIRemoteDebugApplication::PyIRemoteDebugApplication(IUnknown *pdisp) : PyIUnknown(pdisp) { ob_type = &type; }

PyIRemoteDebugApplication::~PyIRemoteDebugApplication() {}

/* static */ IRemoteDebugApplication *PyIRemoteDebugApplication::GetI(PyObject *self)
{
    return (IRemoteDebugApplication *)PyIUnknown::GetI(self);
}

// @pymethod |PyIRemoteDebugApplication|ResumeFromBreakPoint|Continue an application which is currently in a breakpoint.
PyObject *PyIRemoteDebugApplication::ResumeFromBreakPoint(PyObject *self, PyObject *args)
{
    IRemoteDebugApplication *pIRDA = GetI(self);
    if (pIRDA == NULL)
        return NULL;
    // @pyparm <o PyIRemoteDebugApplicationThread>|prptFocus||Description for prptFocus
    // @pyparm int|bra||Break resume action
    // @pyparm int|era||Error resume action
    PyObject *obprptFocus;
    BREAKRESUMEACTION bra;
    ERRORRESUMEACTION era;
    if (!PyArg_ParseTuple(args, "Oii:ResumeFromBreakPoint", &obprptFocus, &bra, &era))
        return NULL;
    IRemoteDebugApplicationThread *prptFocus;
    BOOL bPythonIsHappy = TRUE;
    if (!PyCom_InterfaceFromPyInstanceOrObject(obprptFocus, IID_IRemoteDebugApplicationThread, (void **)&prptFocus,
                                               FALSE /* bNoneOK */))
        bPythonIsHappy = FALSE;
    if (!bPythonIsHappy)
        return NULL;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIRDA->ResumeFromBreakPoint(prptFocus, bra, era);
    prptFocus->Release();
    PY_INTERFACE_POSTCALL;
    if (FAILED(hr))
        return SetPythonCOMError(self, hr);
    Py_INCREF(Py_None);
    return Py_None;
}

// @pymethod |PyIRemoteDebugApplication|CauseBreak|Causes the application to break into the debugger at the earliest
// opportunity.
PyObject *PyIRemoteDebugApplication::CauseBreak(PyObject *self, PyObject *args)
{
    // @comm  Note that a long time may elapse before the application actually breaks, particularly if
    // the application is not currently executing script code.
    IRemoteDebugApplication *pIRDA = GetI(self);
    if (pIRDA == NULL)
        return NULL;
    if (!PyArg_ParseTuple(args, ":CauseBreak"))
        return NULL;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIRDA->CauseBreak();
    PY_INTERFACE_POSTCALL;
    if (FAILED(hr))
        return SetPythonCOMError(self, hr);
    Py_INCREF(Py_None);
    return Py_None;
}

// @pymethod |PyIRemoteDebugApplication|ConnectDebugger|Connects a debugger to the application.
PyObject *PyIRemoteDebugApplication::ConnectDebugger(PyObject *self, PyObject *args)
{
    // @comm Only one debugger may be connected at a
    // time; this method fails if there is already a debugger connected.
    IRemoteDebugApplication *pIRDA = GetI(self);
    if (pIRDA == NULL)
        return NULL;
    // @pyparm <o PyIApplicationDebugger>|pad||Description for pad
    PyObject *obpad;
    if (!PyArg_ParseTuple(args, "O:ConnectDebugger", &obpad))
        return NULL;
    IApplicationDebugger *pad;
    BOOL bPythonIsHappy = TRUE;
    if (!PyCom_InterfaceFromPyInstanceOrObject(obpad, IID_IApplicationDebugger, (void **)&pad, FALSE /* bNoneOK */))
        bPythonIsHappy = FALSE;
    if (!bPythonIsHappy)
        return NULL;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIRDA->ConnectDebugger(pad);
    pad->Release();
    PY_INTERFACE_POSTCALL;
    if (FAILED(hr))
        return SetPythonCOMError(self, hr);
    Py_INCREF(Py_None);
    return Py_None;
}

// @pymethod |PyIRemoteDebugApplication|DisconnectDebugger|Disconnects the current debugger from the application.
PyObject *PyIRemoteDebugApplication::DisconnectDebugger(PyObject *self, PyObject *args)
{
    IRemoteDebugApplication *pIRDA = GetI(self);
    if (pIRDA == NULL)
        return NULL;
    if (!PyArg_ParseTuple(args, ":DisconnectDebugger"))
        return NULL;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIRDA->DisconnectDebugger();
    PY_INTERFACE_POSTCALL;
    if (FAILED(hr))
        return SetPythonCOMError(self, hr);
    Py_INCREF(Py_None);
    return Py_None;
}

// @pymethod <o PyIApplicationDebugger>|PyIRemoteDebugApplication|GetDebugger|Returns the current debugger connected to
// the application.
PyObject *PyIRemoteDebugApplication::GetDebugger(PyObject *self, PyObject *args)
{
    IRemoteDebugApplication *pIRDA = GetI(self);
    if (pIRDA == NULL)
        return NULL;
    if (!PyArg_ParseTuple(args, ":GetDebugger"))
        return NULL;
    IApplicationDebugger *pad;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIRDA->GetDebugger(&pad);
    PY_INTERFACE_POSTCALL;
    if (FAILED(hr))
        return SetPythonCOMError(self, hr);
    return PyCom_PyObjectFromIUnknown(pad, IID_IApplicationDebugger, FALSE);
}

// @pymethod <o PyIUnknown>|PyIRemoteDebugApplication|CreateInstanceAtApplication|Create objects in the application
// process address space.
PyObject *PyIRemoteDebugApplication::CreateInstanceAtApplication(PyObject *self, PyObject *args)
{
    // @comm Provides a mechanism for the debugger IDE, running out-of-process to the
    // application, to create objects in the application process.
    // This method simply delegates to CoCreateInstance.
    IRemoteDebugApplication *pIRDA = GetI(self);
    if (pIRDA == NULL)
        return NULL;
    // @pyparm <o PyIID>|rclsid||Description for rclsid
    // @pyparm <o PyIUnknown>|pUnkOuter||Description for pUnkOuter
    // @pyparm int|dwClsContext||Description for dwClsContext
    // @pyparm <o PyIID>|riid||Description for riid
    PyObject *obrclsid;
    PyObject *obpUnkOuter;
    DWORD dwClsContext;
    PyObject *obriid;
    if (!PyArg_ParseTuple(args, "OOiO:CreateInstanceAtApplication", &obrclsid, &obpUnkOuter, &dwClsContext, &obriid))
        return NULL;
    IID rclsid;
    IUnknown *pUnkOuter;
    IID riid;
    IUnknown *ppvObject;
    BOOL bPythonIsHappy = TRUE;
    if (!PyWinObject_AsIID(obrclsid, &rclsid))
        bPythonIsHappy = FALSE;
    if (!PyWinObject_AsIID(obriid, &riid))
        bPythonIsHappy = FALSE;
    if (!bPythonIsHappy)
        return NULL;
    if (!PyCom_InterfaceFromPyInstanceOrObject(obpUnkOuter, IID_IUnknown, (void **)&pUnkOuter, FALSE /* bNoneOK */))
        bPythonIsHappy = FALSE;
    if (!bPythonIsHappy)
        return NULL;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIRDA->CreateInstanceAtApplication(rclsid, pUnkOuter, dwClsContext, riid, &ppvObject);
    pUnkOuter->Release();
    PY_INTERFACE_POSTCALL;
    if (FAILED(hr))
        return SetPythonCOMError(self, hr);

    return PyCom_PyObjectFromIUnknown(ppvObject, IID_IUnknown, FALSE);
}

// @pymethod |PyIRemoteDebugApplication|QueryAlive|Returns True if alive, else False.
PyObject *PyIRemoteDebugApplication::QueryAlive(PyObject *self, PyObject *args)
{
    IRemoteDebugApplication *pIRDA = GetI(self);
    if (pIRDA == NULL)
        return NULL;
    if (!PyArg_ParseTuple(args, ":QueryAlive"))
        return NULL;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIRDA->QueryAlive();
    PY_INTERFACE_POSTCALL;
    return PyLong_FromLong(hr == S_OK);
}

// @pymethod <o PyIEnumRemoteDebugApplicationThreads>|PyIRemoteDebugApplication|EnumThreads|Enumerates all threads known
// to be associated with the application.
PyObject *PyIRemoteDebugApplication::EnumThreads(PyObject *self, PyObject *args)
{
    // @comm New threads may be added at any time.
    IRemoteDebugApplication *pIRDA = GetI(self);
    if (pIRDA == NULL)
        return NULL;
    if (!PyArg_ParseTuple(args, ":EnumThreads"))
        return NULL;
    IEnumRemoteDebugApplicationThreads *perdat;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIRDA->EnumThreads(&perdat);
    PY_INTERFACE_POSTCALL;
    if (FAILED(hr))
        return SetPythonCOMError(self, hr);
    return PyCom_PyObjectFromIUnknown(perdat, IID_IEnumRemoteDebugApplicationThreads, FALSE);
}

// @pymethod |PyIRemoteDebugApplication|GetName|Description of GetName.
PyObject *PyIRemoteDebugApplication::GetName(PyObject *self, PyObject *args)
{
    IRemoteDebugApplication *pIRDA = GetI(self);
    if (pIRDA == NULL)
        return NULL;
    if (!PyArg_ParseTuple(args, ":GetName"))
        return NULL;
    BSTR pbstrName;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIRDA->GetName(&pbstrName);
    PY_INTERFACE_POSTCALL;
    if (FAILED(hr))
        return SetPythonCOMError(self, hr);

    PyObject *obpbstrName = MakeBstrToObj(pbstrName);
    PyObject *pyretval = Py_BuildValue("O", obpbstrName);
    Py_XDECREF(obpbstrName);
    SysFreeString(pbstrName);
    return pyretval;
}

// @pymethod <o PyIDebugApplicationNode>|PyIRemoteDebugApplication|GetRootNode|Returns the application node under which
// all nodes associated with the application are added.
PyObject *PyIRemoteDebugApplication::GetRootNode(PyObject *self, PyObject *args)
{
    IRemoteDebugApplication *pIRDA = GetI(self);
    if (pIRDA == NULL)
        return NULL;
    if (!PyArg_ParseTuple(args, ":GetRootNode"))
        return NULL;
    IDebugApplicationNode *pNode;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIRDA->GetRootNode(&pNode);
    PY_INTERFACE_POSTCALL;
    if (FAILED(hr))
        return SetPythonCOMError(self, hr);
    return PyCom_PyObjectFromIUnknown(pNode, IID_IDebugApplicationNode, FALSE);
}

// @pymethod <o IEnumDebugExpressionContexts>|PyIRemoteDebugApplication|EnumGlobalExpressionContexts|Enumerates all
// global expression contexts
PyObject *PyIRemoteDebugApplication::EnumGlobalExpressionContexts(PyObject *self, PyObject *args)
{
    IRemoteDebugApplication *pIRDA = GetI(self);
    if (pIRDA == NULL)
        return NULL;
    if (!PyArg_ParseTuple(args, ":EnumGlobalExpressionContexts"))
        return NULL;
    IEnumDebugExpressionContexts *perdat;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIRDA->EnumGlobalExpressionContexts(&perdat);
    PY_INTERFACE_POSTCALL;
    if (FAILED(hr))
        return SetPythonCOMError(self, hr);
    return PyCom_PyObjectFromIUnknown(perdat, IID_IEnumDebugExpressionContexts, FALSE);
}

// @object PyIRemoteDebugApplication|Description of the interface
static struct PyMethodDef PyIRemoteDebugApplication_methods[] = {
    {"ResumeFromBreakPoint", PyIRemoteDebugApplication::ResumeFromBreakPoint,
     1},  // @pymeth ResumeFromBreakPoint|Continue an application which is currently in a breakpoint.
    {"CauseBreak", PyIRemoteDebugApplication::CauseBreak,
     1},  // @pymeth CauseBreak|Causes the application to break into the debugger at the earliest opportunity.
    {"ConnectDebugger", PyIRemoteDebugApplication::ConnectDebugger,
     1},  // @pymeth ConnectDebugger|Connects a debugger to the application.
    {"DisconnectDebugger", PyIRemoteDebugApplication::DisconnectDebugger,
     1},  // @pymeth DisconnectDebugger|Disconnects the current debugger from the application.
    {"GetDebugger", PyIRemoteDebugApplication::GetDebugger,
     1},  // @pymeth GetDebugger|Returns the current debugger connected to the application.
    {"CreateInstanceAtApplication", PyIRemoteDebugApplication::CreateInstanceAtApplication,
     1},  // @pymeth CreateInstanceAtApplication|Create objects in the application process address space.
    {"QueryAlive", PyIRemoteDebugApplication::QueryAlive,
     1},  // @pymeth QueryAlive|Indicates if the application is alive.
    {"EnumThreads", PyIRemoteDebugApplication::EnumThreads,
     1},  // @pymeth EnumThreads|Enumerates all threads known to be associated with the application.
    {"GetName", PyIRemoteDebugApplication::GetName, 1},  // @pymeth GetName|Description of GetName
    {"GetRootNode", PyIRemoteDebugApplication::GetRootNode,
     1},  // @pymeth GetRootNode|Returns the application node under which all nodes associated with the application are
          // added.
    {"EnumGlobalExpressionContexts", PyIRemoteDebugApplication::EnumGlobalExpressionContexts,
     1},  // @pymeth EnumGlobalExpressionContexts|Enumerates all global expression contexts.
    {NULL}};

PyComTypeObject PyIRemoteDebugApplication::type("PyIRemoteDebugApplication", &PyIUnknown::type,
                                                sizeof(PyIRemoteDebugApplication), PyIRemoteDebugApplication_methods,
                                                GET_PYCOM_CTOR(PyIRemoteDebugApplication));
// ---------------------------------------------------
//
// Gateway Implementation

STDMETHODIMP PyGRemoteDebugApplication::ResumeFromBreakPoint(
    /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prptFocus,
    /* [in] */ BREAKRESUMEACTION bra,
    /* [in] */ ERRORRESUMEACTION era)
{
    PY_GATEWAY_METHOD;
    PyObject *obprptFocus = PyCom_PyObjectFromIUnknown(prptFocus, IID_IRemoteDebugApplicationThread, TRUE);
    HRESULT hr = InvokeViaPolicy("ResumeFromBreakPoint", NULL, "Oii", obprptFocus, bra, era);
    Py_XDECREF(obprptFocus);
    return hr;
}

STDMETHODIMP PyGRemoteDebugApplication::CauseBreak(void)
{
    PY_GATEWAY_METHOD;
    HRESULT hr = InvokeViaPolicy("CauseBreak", NULL);
    return hr;
}

STDMETHODIMP PyGRemoteDebugApplication::ConnectDebugger(
    /* [in] */ IApplicationDebugger __RPC_FAR *pad)
{
    PY_GATEWAY_METHOD;
    PyObject *obpad = PyCom_PyObjectFromIUnknown(pad, IID_IApplicationDebugger, TRUE);
    HRESULT hr = InvokeViaPolicy("ConnectDebugger", NULL, "O", obpad);
    Py_XDECREF(obpad);
    return hr;
}

STDMETHODIMP PyGRemoteDebugApplication::DisconnectDebugger(void)
{
    PY_GATEWAY_METHOD;
    HRESULT hr = InvokeViaPolicy("DisconnectDebugger", NULL);
    return hr;
}

STDMETHODIMP PyGRemoteDebugApplication::GetDebugger(
    /* [out] */ IApplicationDebugger __RPC_FAR *__RPC_FAR *pad)
{
    PY_GATEWAY_METHOD;
    if (pad == NULL)
        return E_POINTER;
    PyObject *result;
    HRESULT hr = InvokeViaPolicy("GetDebugger", &result);
    if (FAILED(hr))
        return hr;
    // Process the Python results, and convert back to the real params
    PyObject *obpad;
    if (!PyArg_Parse(result, "O", &obpad))
        return PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
    BOOL bPythonIsHappy = TRUE;
    if (!PyCom_InterfaceFromPyInstanceOrObject(obpad, IID_IApplicationDebugger, (void **)pad, FALSE /* bNoneOK */))
        bPythonIsHappy = FALSE;
    if (!bPythonIsHappy)
        hr = PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
    Py_DECREF(result);
    return hr;
}

STDMETHODIMP PyGRemoteDebugApplication::CreateInstanceAtApplication(
    /* [in] */ REFCLSID rclsid,
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ DWORD dwClsContext,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject)
{
    PY_GATEWAY_METHOD;
    if (ppvObject == NULL)
        return E_POINTER;
    PyObject *obrclsid = PyWinObject_FromIID(rclsid);
    PyObject *obpUnkOuter = PyCom_PyObjectFromIUnknown(pUnkOuter, IID_IUnknown, TRUE);
    PyObject *obriid = PyWinObject_FromIID(riid);
    PyObject *result;
    HRESULT hr =
        InvokeViaPolicy("CreateInstanceAtApplication", &result, "OOiO", obrclsid, obpUnkOuter, dwClsContext, obriid);
    Py_XDECREF(obrclsid);
    Py_XDECREF(obpUnkOuter);
    Py_XDECREF(obriid);
    if (FAILED(hr))
        return hr;
    // Process the Python results, and convert back to the real params
    PyObject *obppvObject;
    if (!PyArg_Parse(result, "O", &obppvObject))
        return PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
    BOOL bPythonIsHappy = TRUE;
    if (!PyCom_InterfaceFromPyInstanceOrObject(obppvObject, IID_IUnknown, (void **)ppvObject, FALSE /* bNoneOK */))
        bPythonIsHappy = FALSE;
    if (!bPythonIsHappy)
        hr = PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
    Py_DECREF(result);
    return hr;
}

STDMETHODIMP PyGRemoteDebugApplication::EnumThreads(IEnumRemoteDebugApplicationThreads __RPC_FAR *__RPC_FAR *pperdat)
{
    PY_GATEWAY_METHOD;
    if (pperdat == NULL)
        return E_POINTER;
    PyObject *result;
    HRESULT hr = InvokeViaPolicy("EnumThreads", &result);
    if (FAILED(hr))
        return hr;
    // Process the Python results, and convert back to the real params
    PyObject *oberdat;
    if (!PyArg_Parse(result, "O", &oberdat))
        return PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
    BOOL bPythonIsHappy = TRUE;
    if (!PyCom_InterfaceFromPyInstanceOrObject(oberdat, IID_IEnumRemoteDebugApplicationThreads, (void **)pperdat,
                                               FALSE /* bNoneOK */))
        bPythonIsHappy = FALSE;
    if (!bPythonIsHappy)
        hr = PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
    Py_DECREF(result);
    return hr;
}
STDMETHODIMP PyGRemoteDebugApplication::QueryAlive(void)
{
    PY_GATEWAY_METHOD;
    HRESULT hr = InvokeViaPolicy("QueryAlive", NULL);
    return hr;
}

STDMETHODIMP PyGRemoteDebugApplication::GetName(
    /* [out] */ BSTR __RPC_FAR *pbstrName)
{
    PY_GATEWAY_METHOD;
    PyObject *result;
    HRESULT hr = InvokeViaPolicy("GetName", &result);
    if (FAILED(hr))
        return hr;
    // Process the Python results, and convert back to the real params
    PyObject *obpbstrName;
    if (!PyArg_Parse(result, "O", &obpbstrName))
        return PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
    BOOL bPythonIsHappy = TRUE;
    if (!PyCom_BstrFromPyObject(obpbstrName, pbstrName))
        bPythonIsHappy = FALSE;
    if (!bPythonIsHappy)
        hr = PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
    Py_DECREF(result);
    return hr;
}

STDMETHODIMP PyGRemoteDebugApplication::GetRootNode(IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanRoot)
{
    PY_GATEWAY_METHOD;
    if (ppdanRoot == NULL)
        return E_POINTER;
    PyObject *result;
    HRESULT hr = InvokeViaPolicy("GetRootNode", &result);
    if (FAILED(hr))
        return hr;
    // Process the Python results, and convert back to the real params
    PyObject *obnode;
    if (!PyArg_Parse(result, "O", &obnode))
        return PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
    BOOL bPythonIsHappy = TRUE;
    if (!PyCom_InterfaceFromPyInstanceOrObject(obnode, IID_IDebugApplicationNode, (void **)ppdanRoot,
                                               FALSE /* bNoneOK */))
        bPythonIsHappy = FALSE;
    if (!bPythonIsHappy)
        hr = PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
    Py_DECREF(result);
    return hr;
}

STDMETHODIMP PyGRemoteDebugApplication::EnumGlobalExpressionContexts(
    IEnumDebugExpressionContexts __RPC_FAR *__RPC_FAR *ppedec)
{
    PY_GATEWAY_METHOD;
    if (ppedec == NULL)
        return E_POINTER;
    PyObject *result;
    HRESULT hr = InvokeViaPolicy("EnumGlobalExpressionContexts", &result);
    if (FAILED(hr))
        return hr;
    // Process the Python results, and convert back to the real params
    PyObject *oberdat;
    if (!PyArg_Parse(result, "O", &oberdat))
        return PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
    BOOL bPythonIsHappy = TRUE;
    if (!PyCom_InterfaceFromPyInstanceOrObject(oberdat, IID_IEnumDebugExpressionContexts, (void **)ppedec,
                                               TRUE /* bNoneOK */))
        bPythonIsHappy = FALSE;
    if (!bPythonIsHappy)
        hr = PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
    Py_DECREF(result);
    return hr;
}
