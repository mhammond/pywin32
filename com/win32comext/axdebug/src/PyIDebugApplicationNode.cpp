// This file implements the IDebugApplicationNode Interface and Gateway for Python.
// Generated by makegw.py

#include "stdafx.h"
#include "PythonCOM.h"
#include "PythonCOMServer.h"
#include "PyIDebugDocumentInfo.h"
#include "PyIDebugDocumentProvider.h"
#include "PyIDebugApplicationNode.h"

// @doc - This file contains autoduck documentation
// ---------------------------------------------------
//
// Interface Implementation

PyIDebugApplicationNode::PyIDebugApplicationNode(IUnknown *pdisp) : PyIDebugDocumentProvider(pdisp) { ob_type = &type; }

PyIDebugApplicationNode::~PyIDebugApplicationNode() {}

/* static */ IDebugApplicationNode *PyIDebugApplicationNode::GetI(PyObject *self)
{
    return (IDebugApplicationNode *)PyIDebugDocumentProvider::GetI(self);
}

// @pymethod |PyIDebugApplicationNode|EnumChildren|Description of EnumChildren.
PyObject *PyIDebugApplicationNode::EnumChildren(PyObject *self, PyObject *args)
{
    PY_INTERFACE_METHOD;
    IDebugApplicationNode *pIDAN = GetI(self);
    if (pIDAN == NULL)
        return NULL;
    IEnumDebugApplicationNodes *pperddp;
    if (!PyArg_ParseTuple(args, ":EnumChildren"))
        return NULL;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIDAN->EnumChildren(&pperddp);
    PY_INTERFACE_POSTCALL;
    if (FAILED(hr))
        return OleSetOleError(hr);
    return PyCom_PyObjectFromIUnknown(pperddp, IID_IEnumDebugApplicationNodes, FALSE);
}

// @pymethod <o PyIDebugApplicationNode>|PyIDebugApplicationNode|GetParent|Returns the parent node.
PyObject *PyIDebugApplicationNode::GetParent(PyObject *self, PyObject *args)
{
    PY_INTERFACE_METHOD;
    IDebugApplicationNode *pIDAN = GetI(self);
    if (pIDAN == NULL)
        return NULL;
    IDebugApplicationNode *pprddp;
    if (!PyArg_ParseTuple(args, ":GetParent"))
        return NULL;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIDAN->GetParent(&pprddp);
    PY_INTERFACE_POSTCALL;
    if (FAILED(hr))
        return OleSetOleError(hr);
    return PyCom_PyObjectFromIUnknown(pprddp, IID_IDebugApplicationNode, FALSE);
}

// @pymethod |PyIDebugApplicationNode|SetDocumentProvider|Description of SetDocumentProvider.
PyObject *PyIDebugApplicationNode::SetDocumentProvider(PyObject *self, PyObject *args)
{
    PY_INTERFACE_METHOD;
    IDebugApplicationNode *pIDAN = GetI(self);
    if (pIDAN == NULL)
        return NULL;
    // @pyparm <o PyIDebugDocumentProvider>|pddp||Description for pddp
    PyObject *obpddp;
    IDebugDocumentProvider *pddp;
    if (!PyArg_ParseTuple(args, "O:SetDocumentProvider", &obpddp))
        return NULL;
    BOOL bPythonIsHappy = TRUE;
    if (!PyCom_InterfaceFromPyInstanceOrObject(obpddp, IID_IDebugDocumentProvider, (void **)&pddp, FALSE /* bNoneOK */))
        bPythonIsHappy = FALSE;
    if (!bPythonIsHappy)
        return NULL;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIDAN->SetDocumentProvider(pddp);
    pddp->Release();
    PY_INTERFACE_POSTCALL;
    if (FAILED(hr))
        return OleSetOleError(hr);
    Py_INCREF(Py_None);
    return Py_None;
}

// @pymethod |PyIDebugApplicationNode|Close|Description of Close.
PyObject *PyIDebugApplicationNode::Close(PyObject *self, PyObject *args)
{
    PY_INTERFACE_METHOD;
    IDebugApplicationNode *pIDAN = GetI(self);
    if (pIDAN == NULL)
        return NULL;
    if (!PyArg_ParseTuple(args, ":Close"))
        return NULL;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIDAN->Close();
    PY_INTERFACE_POSTCALL;
    if (FAILED(hr))
        return OleSetOleError(hr);
    Py_INCREF(Py_None);
    return Py_None;
}

// @pymethod |PyIDebugApplicationNode|Attach|Attach a node to its parent.
PyObject *PyIDebugApplicationNode::Attach(PyObject *self, PyObject *args)
{
    PY_INTERFACE_METHOD;
    IDebugApplicationNode *pIDAN = GetI(self);
    if (pIDAN == NULL)
        return NULL;
    // @pyparm <o PyIDebugApplicationNode>|pdanParent||The parent node.  None is not acceptable.
    PyObject *obpdanParent;
    IDebugApplicationNode *pdanParent;
    if (!PyArg_ParseTuple(args, "O:Attach", &obpdanParent))
        return NULL;
    BOOL bPythonIsHappy = TRUE;
    if (!PyCom_InterfaceFromPyInstanceOrObject(obpdanParent, IID_IDebugApplicationNode, (void **)&pdanParent,
                                               FALSE /* bNoneOK */))
        bPythonIsHappy = FALSE;
    if (!bPythonIsHappy)
        return NULL;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIDAN->Attach(pdanParent);
    pdanParent->Release();
    PY_INTERFACE_POSTCALL;
    if (FAILED(hr))
        return OleSetOleError(hr);
    Py_INCREF(Py_None);
    return Py_None;
}

// @pymethod |PyIDebugApplicationNode|Detach|Detach a node from its parent.
PyObject *PyIDebugApplicationNode::Detach(PyObject *self, PyObject *args)
{
    PY_INTERFACE_METHOD;
    IDebugApplicationNode *pIDAN = GetI(self);
    if (pIDAN == NULL)
        return NULL;
    if (!PyArg_ParseTuple(args, ":Detach"))
        return NULL;
    PY_INTERFACE_PRECALL;
    HRESULT hr = pIDAN->Detach();
    PY_INTERFACE_POSTCALL;
    if (FAILED(hr))
        return OleSetOleError(hr);
    Py_INCREF(Py_None);
    return Py_None;
}

// @object PyIDebugApplicationNode|Provides the functionality of IDebugDocumentProvider, plus a context within a project
// tree.  Derived from <o PyIDebugDocumentProvider>
static struct PyMethodDef PyIDebugApplicationNode_methods[] = {
    {"EnumChildren", PyIDebugApplicationNode::EnumChildren, 1},  // @pymeth EnumChildren|Description of EnumChildren
    {"GetParent", PyIDebugApplicationNode::GetParent, 1},        // @pymeth GetParent|Description of GetParent
    {"SetDocumentProvider", PyIDebugApplicationNode::SetDocumentProvider,
     1},                                             // @pymeth SetDocumentProvider|Description of SetDocumentProvider
    {"Close", PyIDebugApplicationNode::Close, 1},    // @pymeth Close|Description of Close
    {"Attach", PyIDebugApplicationNode::Attach, 1},  // @pymeth Attach|Attach a node to its parent.
    {"Detach", PyIDebugApplicationNode::Detach, 1},  // @pymeth Detach|Detach a node from its parent.
    {NULL}};

PyComTypeObject PyIDebugApplicationNode::type("PyIDebugApplicationNode", &PyIDebugDocumentProvider::type,
                                              sizeof(PyIDebugApplicationNode), PyIDebugApplicationNode_methods,
                                              GET_PYCOM_CTOR(PyIDebugApplicationNode));
// ---------------------------------------------------
//
// Gateway Implementation

// Std delegation

// IDebugDocumentInfo
STDMETHODIMP PyGDebugApplicationNode::GetName(DOCUMENTNAMETYPE dnt, BSTR __RPC_FAR *pbstrName)
{
    return PyGDebugDocumentProvider::GetName(dnt, pbstrName);
}
STDMETHODIMP PyGDebugApplicationNode::GetDocumentClassId(GUID __RPC_FAR *pclsidDocument)
{
    return PyGDebugDocumentProvider::GetDocumentClassId(pclsidDocument);
}

// IDebugDocumentProvider
STDMETHODIMP PyGDebugApplicationNode::GetDocument(IDebugDocument __RPC_FAR *__RPC_FAR *ppssd)
{
    return PyGDebugDocumentProvider::GetDocument(ppssd);
}

// IDebugDocumentNode
STDMETHODIMP PyGDebugApplicationNode::EnumChildren(
    /* [out] */ IEnumDebugApplicationNodes __RPC_FAR *__RPC_FAR *pperddp)
{
    PY_GATEWAY_METHOD;
    if (pperddp == NULL)
        return E_POINTER;
    PyObject *result;
    HRESULT hr = InvokeViaPolicy("EnumChildren", &result);
    if (FAILED(hr))
        return hr;
    // Process the Python results, and convert back to the real params
    PyObject *obpperddp;
    if (!PyArg_Parse(result, "O", &obpperddp))
        return PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
    BOOL bPythonIsHappy = TRUE;
    if (!PyCom_InterfaceFromPyInstanceOrObject(obpperddp, IID_IEnumDebugApplicationNodes, (void **)pperddp,
                                               FALSE /* bNoneOK */))
        bPythonIsHappy = FALSE;
    if (!bPythonIsHappy)
        hr = PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
    Py_DECREF(result);
    return hr;
}

STDMETHODIMP PyGDebugApplicationNode::GetParent(
    /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *pprddp)
{
    PY_GATEWAY_METHOD;
    if (pprddp == NULL)
        return E_POINTER;
    PyObject *result;
    HRESULT hr = InvokeViaPolicy("GetParent", &result);
    if (FAILED(hr))
        return hr;
    // Process the Python results, and convert back to the real params
    PyObject *obpprddp;
    if (!PyArg_Parse(result, "O", &obpprddp))
        return PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
    BOOL bPythonIsHappy = TRUE;
    if (!PyCom_InterfaceFromPyInstanceOrObject(obpprddp, IID_IDebugApplicationNode, (void **)pprddp,
                                               FALSE /* bNoneOK */))
        bPythonIsHappy = FALSE;
    if (!bPythonIsHappy)
        hr = PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
    Py_DECREF(result);
    return hr;
}

STDMETHODIMP PyGDebugApplicationNode::SetDocumentProvider(
    /* [in] */ IDebugDocumentProvider __RPC_FAR *pddp)
{
    PY_GATEWAY_METHOD;
    PyObject *obpddp;
    obpddp = PyCom_PyObjectFromIUnknown(pddp, IID_IDebugDocumentProvider, TRUE);
    HRESULT hr = InvokeViaPolicy("SetDocumentProvider", NULL, "O", obpddp);
    Py_XDECREF(obpddp);
    return hr;
}

STDMETHODIMP PyGDebugApplicationNode::Close(void)
{
    PY_GATEWAY_METHOD;
    HRESULT hr = InvokeViaPolicy("Close", NULL);
    return hr;
}

STDMETHODIMP PyGDebugApplicationNode::Attach(
    /* [in] */ IDebugApplicationNode __RPC_FAR *pdanParent)
{
    PY_GATEWAY_METHOD;
    PyObject *obpdanParent;
    obpdanParent = PyCom_PyObjectFromIUnknown(pdanParent, IID_IDebugApplicationNode, TRUE);
    HRESULT hr = InvokeViaPolicy("Attach", NULL, "O", obpdanParent);
    Py_XDECREF(obpdanParent);
    return hr;
}

STDMETHODIMP PyGDebugApplicationNode::Detach(void)
{
    PY_GATEWAY_METHOD;
    HRESULT hr = InvokeViaPolicy("Detach", NULL);
    return hr;
}
