// This file implements the IShellLibrary Interface for Python.
// Generated by makegw.py

#include "shell_pch.h"

// Requires Windows 7 SDK to build
#if WINVER >= 0x0601

#include "PyIShellLibrary.h"

// @doc - This file contains autoduck documentation
// ---------------------------------------------------
//
// Interface Implementation

PyIShellLibrary::PyIShellLibrary(IUnknown *pdisp):
	PyIUnknown(pdisp)
{
	ob_type = &type;
}

PyIShellLibrary::~PyIShellLibrary()
{
}

/* static */ IShellLibrary *PyIShellLibrary::GetI(PyObject *self)
{
	return (IShellLibrary *)PyIUnknown::GetI(self);
}

// @pymethod |PyIShellLibrary|LoadLibraryFromItem|Loads an existing library file
PyObject *PyIShellLibrary::LoadLibraryFromItem(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	IShellItem *Library;
	PyObject *obLibrary;
	DWORD Mode;
	// @pyparm <o PyIShellItem>|Library||Shell item interface representing the library file
	// @pyparm int|Mode||Access mode, combination of storagecon.STGM_* flags
	if ( !PyArg_ParseTuple(args, "Ok:LoadLibraryFromItem", &obLibrary, &Mode) )
		return NULL;
	if (!PyCom_InterfaceFromPyObject(obLibrary, IID_IShellItem, (void **)&Library, FALSE))
		return NULL;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->LoadLibraryFromItem(Library, Mode);
	Library->Release();
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	Py_INCREF(Py_None);
	return Py_None;
}

// @pymethod |PyIShellLibrary|LoadLibraryFromKnownFolder|Initializes library from a known folder
PyObject *PyIShellLibrary::LoadLibraryFromKnownFolder(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	IID Library;
	DWORD Mode;
	// @pyparm <o PyIID>|Library||Known folder id, shell.FOLDERID_*
	// @pyparm int|Mode||Access mode, combination of storagecon.STGM_* flags
	if ( !PyArg_ParseTuple(args, "O&k:LoadLibraryFromKnownFolder",
		PyWinObject_AsIID, &Library, &Mode))
		return NULL;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->LoadLibraryFromKnownFolder(Library, Mode);
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	Py_INCREF(Py_None);
	return Py_None;
}

// @pymethod |PyIShellLibrary|AddFolder|Includes a folder
PyObject *PyIShellLibrary::AddFolder(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	IShellItem *Location;
	PyObject *obLocation;
	// @pyparm <o PyIShellItem>|Location||Shell item interface representing the folder
	if ( !PyArg_ParseTuple(args, "O:AddFolder", &obLocation))
		return NULL;
	if (!PyCom_InterfaceFromPyObject(obLocation, IID_IShellItem, (void **)&Location, FALSE))
		return NULL;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->AddFolder(Location);
	Location->Release();
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	Py_INCREF(Py_None);
	return Py_None;

}

// @pymethod |PyIShellLibrary|RemoveFolder|Removes a folder
PyObject *PyIShellLibrary::RemoveFolder(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	IShellItem *Location;
	PyObject *obLocation;
	// @pyparm <o PyIShellItem>|Location||Shell item interface representing the folder
	if ( !PyArg_ParseTuple(args, "O:RemoveFolder", &obLocation))
		return NULL;
	if (!PyCom_InterfaceFromPyObject(obLocation, IID_IShellItem, (void **)&Location, FALSE))
		return NULL;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->RemoveFolder(Location);
	Location->Release();
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	Py_INCREF(Py_None);
	return Py_None;
}

// @pymethod <o PyIShellItemArray>|PyIShellLibrary|GetFolders|Retrieves a collection of folders in the library
PyObject *PyIShellLibrary::GetFolders(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	// @pyparm int|Filter|LFF_ALLITEMS|Specifies what types of folder to return (shellcon.LFF_*)
	// @pyparm <o PyIID>|riid|IID_IShellItemArray|The interface to return, IObjectCollection and IObjectArray also accepted.
	LIBRARYFOLDERFILTER Filter = LFF_ALLITEMS;
	IID riid = IID_IShellItemArray;
	void *pv;
	if ( !PyArg_ParseTuple(args, "|iO&:GetFolders", &Filter, PyWinObject_AsIID, &riid))
		return NULL;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->GetFolders(Filter, riid, &pv);
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	return PyCom_PyObjectFromIUnknown((IUnknown *)pv, riid, FALSE);
}

// @pymethod <o PyIShellItem>|PyIShellLibrary|ResolveFolder|Attempts to locate a folder that has been moved or renamed
PyObject *PyIShellLibrary::ResolveFolder(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	IShellItem *FolderToResolve;
	PyObject *obFolderToResolve;
	DWORD Timeout;
	IID riid = IID_IShellItem;
	// @pyparm <o PyIShellItem>|FolderToResolve||Library item whose location has changed
	// @pyparm int|Timeout||Max search time, specified in milliseconds
	// @pyparm <o PyIID>|riid|IID_IShellItem|The interface to return
	if (!PyArg_ParseTuple(args, "Ok|O&:ResolveFolder",
		&obFolderToResolve, &Timeout,
		PyWinObject_AsIID, &riid))
		return NULL;
	if (!PyCom_InterfaceFromPyObject(obFolderToResolve, IID_IShellItem, (void **)&FolderToResolve, FALSE))
		return NULL;

	void *pv;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->ResolveFolder(FolderToResolve, Timeout, riid, &pv );
	FolderToResolve->Release();
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	return PyCom_PyObjectFromIUnknown((IUnknown *)pv, riid, FALSE);
}

// @pymethod <o PyIShellItem>|PyIShellLibrary|GetDefaultSaveFolder|Returns the default folder in which new items are saved
PyObject *PyIShellLibrary::GetDefaultSaveFolder(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	DEFAULTSAVEFOLDERTYPE Type = DSFT_DETECT;
	IID riid = IID_IShellItem;
	// @pyparm int|Type|DSFT_DETECT|Specifies whether to return public or private save location, shellcon.DSFT_*
	// @pyparm <o PyIID>|riid|IID_IShellItem|The interface to return
	if ( !PyArg_ParseTuple(args, "|iO&:GetDefaultSaveFolder", &Type, PyWinObject_AsIID, &riid))
		return NULL;

	void *pv;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->GetDefaultSaveFolder(Type, riid, &pv);
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	return PyCom_PyObjectFromIUnknown((IUnknown *)pv, riid, FALSE);
}

// @pymethod |PyIShellLibrary|SetDefaultSaveFolder|Sets the default save location
PyObject *PyIShellLibrary::SetDefaultSaveFolder(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	DEFAULTSAVEFOLDERTYPE Type;
	IShellItem *SaveFolder;
	PyObject *obSaveFolder;
	// @pyparm int|Type||Specifies public or private save location, shellcon.DSFT_*
	// @pyparm <o PyIShellItem>|SaveFolder||New default location, must be in the library
	if (!PyArg_ParseTuple(args, "iO:SetDefaultSaveFolder", &Type, &obSaveFolder))
		return NULL;
	if (!PyCom_InterfaceFromPyObject(obSaveFolder, IID_IShellItem, (void **)&SaveFolder, FALSE))
		return NULL;

	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->SetDefaultSaveFolder(Type, SaveFolder);
	SaveFolder->Release();
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	Py_INCREF(Py_None);
	return Py_None;
}

// @pymethod int|PyIShellLibrary|GetOptions|Retrieves library option flags
// @rdesc Returns a combination of shellcon.LOF_* flags
PyObject *PyIShellLibrary::GetOptions(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	LIBRARYOPTIONFLAGS Options;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->GetOptions(&Options);
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	return PyInt_FromLong(Options);
}

// @pymethod |PyIShellLibrary|SetOptions|Sets library option flags
PyObject *PyIShellLibrary::SetOptions(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	LIBRARYOPTIONFLAGS Mask, Options;
	// @pyparm int|Mask||Bitmask of flags to be changed, combination of shellcon.LOF_* values
	// @pyparm int|Options||New options, combination of shellcon.LOF_* values
	if ( !PyArg_ParseTuple(args, "ii:SetOptions", &Mask, &Options))
		return NULL;

	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->SetOptions(Mask, Options);
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	Py_INCREF(Py_None);
	return Py_None;
}

// @pymethod <o PyIID>|PyIShellLibrary|GetFolderType|Returns the library type, shell.FOLDERTYPEID_*
PyObject *PyIShellLibrary::GetFolderType(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	FOLDERTYPEID ft;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->GetFolderType(&ft);
	PY_INTERFACE_POSTCALL;
	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	return PyWinObject_FromIID(ft);
}

// @pymethod |PyIShellLibrary|SetFolderType|Sets the folder type for the library
PyObject *PyIShellLibrary::SetFolderType(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	FOLDERTYPEID ft;
	// @pyparm <o PyIID>|Type||New type, shell.FOLDERTYPEID_*
	if ( !PyArg_ParseTuple(args, "O&:SetFolderType", PyWinObject_AsIID, &ft))
		return NULL;

	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->SetFolderType(ft);
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	Py_INCREF(Py_None);
	return Py_None;
}

// @pymethod str|PyIShellLibrary|GetIcon|Returns the location of the library's icon
// @rdesc Uses "module,resource" format
PyObject *PyIShellLibrary::GetIcon(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	LPWSTR Icon;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->GetIcon(&Icon);
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	PyObject *ret = PyWinObject_FromWCHAR(Icon);
	CoTaskMemFree(Icon);	// Docs don't specify, but this doesn't leak
	return ret;
}

// @pymethod |PyIShellLibrary|SetIcon|Sets the library icon
PyObject *PyIShellLibrary::SetIcon(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	TmpWCHAR Icon;
	PyObject *obIcon;
	// @pyparm str|Icon||Icon location in "module,resource" syntax
	if ( !PyArg_ParseTuple(args, "O:SetIcon", &obIcon) )
		return NULL;
	if (!PyWinObject_AsWCHAR(obIcon, &Icon, FALSE))
		return NULL;

	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->SetIcon(Icon);
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	Py_INCREF(Py_None);
	return Py_None;
}

// @pymethod |PyIShellLibrary|Commit|Saves changes (only if loaded from an existing library)
PyObject *PyIShellLibrary::Commit(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->Commit( );
	PY_INTERFACE_POSTCALL;
	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	Py_INCREF(Py_None);
	return Py_None;
}

// @pymethod <o PyIShellItem>|PyIShellLibrary|Save|Saves the library to a specific location
// @rdesc Returns a shell item for the saved file.
PyObject *PyIShellLibrary::Save(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	IShellItem *FolderToSaveIn, *SavedTo;
	PyObject *obFolderToSaveIn;
	TmpWCHAR LibraryName;
	PyObject *obLibraryName;
	LIBRARYSAVEFLAGS Flags;
	// @pyparm <o PyIShellItem>|FolderToSaveIn||The destination folder, use None to save in current user's Libraries folder 
	// @pyparm str|LibraryName||Filename for the new library, without file extension
	// @pyparm int|Flags||Determines behaviour if file already exists, shellcon.LSF_*
	if ( !PyArg_ParseTuple(args, "OOi:Save", &obFolderToSaveIn, &obLibraryName, &Flags))
		return NULL;
	if (!PyWinObject_AsWCHAR(obLibraryName, &LibraryName, FALSE))
		return NULL;
	if (!PyCom_InterfaceFromPyObject(obFolderToSaveIn, IID_IShellItem, (void **)&FolderToSaveIn, TRUE))
		return NULL;

	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->Save(FolderToSaveIn, LibraryName, Flags, &SavedTo);
	if (FolderToSaveIn)
		FolderToSaveIn->Release();
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	return PyCom_PyObjectFromIUnknown(SavedTo, IID_IShellItem, FALSE);
}

// @pymethod <o PyIShellItem>|PyIShellLibrary|SaveInKnownFolder|Saves the library in a known folder
PyObject *PyIShellLibrary::SaveInKnownFolder(PyObject *self, PyObject *args)
{
	IShellLibrary *pISL = GetI(self);
	if ( pISL == NULL )
		return NULL;
	KNOWNFOLDERID FolderToSaveIn;
	TmpWCHAR LibraryName;
	PyObject *obLibraryName;
	LIBRARYSAVEFLAGS Flags;
	IShellItem *SavedTo;
	// @pyparm <o PyIID>|FolderToSaveIn||The destination folder, shell.FOLDERID_*
	// @pyparm str|LibraryName||Filename for the new library, without file extension
	// @pyparm int|Flags||Determines behaviour if file already exists, shellcon.LSF_*
	if (!PyArg_ParseTuple(args, "O&Oi:SaveInKnownFolder",
		PyWinObject_AsIID, &FolderToSaveIn,
		&obLibraryName, &Flags))
		return NULL;
	if (!PyWinObject_AsWCHAR(obLibraryName, &LibraryName, FALSE))
		return NULL;

	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pISL->SaveInKnownFolder(FolderToSaveIn, LibraryName, Flags, &SavedTo);
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pISL, IID_IShellLibrary );
	return PyCom_PyObjectFromIUnknown(SavedTo, IID_IShellItem, FALSE);
}

// @object PyIShellLibrary|Interface used to access Libraries
// @comm Requires Windows 7 or later
static struct PyMethodDef PyIShellLibrary_methods[] =
{
	{ "LoadLibraryFromItem", PyIShellLibrary::LoadLibraryFromItem, 1 }, // @pymeth LoadLibraryFromItem|Loads an existing library file
	{ "LoadLibraryFromKnownFolder", PyIShellLibrary::LoadLibraryFromKnownFolder, 1 }, // @pymeth LoadLibraryFromKnownFolder|Initializes library from a known folder
	{ "AddFolder", PyIShellLibrary::AddFolder, 1 }, // @pymeth AddFolder|Includes a folder in the library
	{ "RemoveFolder", PyIShellLibrary::RemoveFolder, 1 }, // @pymeth RemoveFolder|Removes a folder
	{ "GetFolders", PyIShellLibrary::GetFolders, 1 }, // @pymeth GetFolders|Retrieves a collection of folders in the library
	{ "ResolveFolder", PyIShellLibrary::ResolveFolder, 1 }, // @pymeth ResolveFolder|Attempts to locate a folder that has been moved or renamed
	{ "GetDefaultSaveFolder", PyIShellLibrary::GetDefaultSaveFolder, 1 }, // @pymeth GetDefaultSaveFolder|Returns the default folder in which new items are saved
	{ "SetDefaultSaveFolder", PyIShellLibrary::SetDefaultSaveFolder, 1 }, // @pymeth SetDefaultSaveFolder|Sets the default save location
	{ "GetOptions", PyIShellLibrary::GetOptions, METH_NOARGS }, // @pymeth GetOptions|Retrieves library option flags
	{ "SetOptions", PyIShellLibrary::SetOptions, 1 }, // @pymeth SetOptions|Sets library option flags
	{ "GetFolderType", PyIShellLibrary::GetFolderType, METH_NOARGS }, // @pymeth GetFolderType|Retrieves the folder type of the library
	{ "SetFolderType", PyIShellLibrary::SetFolderType, 1 }, // @pymeth SetFolderType|Sets the folder type of the library
	{ "GetIcon", PyIShellLibrary::GetIcon, METH_NOARGS }, // @pymeth GetIcon|Returns the location of the library's icon
	{ "SetIcon", PyIShellLibrary::SetIcon, 1 }, // @pymeth SetIcon|Sets the library icon
	{ "Commit", PyIShellLibrary::Commit, METH_NOARGS }, // @pymeth Commit|Saves changes (only if loaded from an existing library)
	{ "Save", PyIShellLibrary::Save, 1 }, // @pymeth Save|Saves the library to a specific location
	{ "SaveInKnownFolder", PyIShellLibrary::SaveInKnownFolder, 1 }, // @pymeth SaveInKnownFolder|Saves the library in a known folder
	{ NULL }
};

PyComTypeObject PyIShellLibrary::type("PyIShellLibrary",
		&PyIUnknown::type,
		sizeof(PyIShellLibrary),
		PyIShellLibrary_methods,
		GET_PYCOM_CTOR(PyIShellLibrary));

#endif // WINVER
