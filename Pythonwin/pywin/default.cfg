# The default keyboard etc configuration file for Pythonwin.
#
# The format of this file is very similar to a Windows INI file.
# Sections are identified with [Section] lines, but comments
# use the standatd Python # character.  Depending on the section,
# lines may not be in the standard "key=value" format.

# NOTE:  You should not need to modify this file.
# Simply create a new .CFG file, and add an entry:
# [General]
# Based On = Default
#
# and add your customisations.  Then select your new configuration 
# from the Pythonwin View/Options/Editor dialog.
# This way you get to add your own customisations,
# but still take advantage of changes to the default
# configuration in new releases.

# See user.cfg and IDLE.cfg for an example extension configuration.
#
##########################################################################

[IDLE Extensions]

# The list of IDLE extensions to load.  The extensions
# AutoIndent, AutoFormat and possibly others are
# "built-in", so do not need specifying.

FormatParagraph
CallTips


[Keys]

# The list of _default_ key definitions.  
#  See [Keys:Interactive] and [Keys:Editor] below for further defs.

#Events of the format <<event-name>> 
# are events defined in IDLE extensions.

Alt+Q             = <<format-paragraph>>

Ctrl+W            = ViewWhitespace
Ctrl+Shift+8      = ViewWhitespace # The MSVC default key def.

Ctrl+Shift+F      = ViewFixedFont

# Auto-complete, call-tips, etc.
Alt+/             = <<expand-word>>
Ctrl+Space   = <<expand-word>>
(           = <<paren-open>>
)           = <<paren-close>>
Up                = <<check-calltip-cancel>>
Down              = <<check-calltip-cancel>>
Left              = <<check-calltip-cancel>>
Right             = <<check-calltip-cancel>>
.                 = KeyDot

# Debugger - These are the MSVC default keys, for want of a better choice.
F9                = DbgBreakpointToggle
F5                = DbgGo
Shift+F5          = DbgClose
F11               = DbgStep
F10               = DbgStepOver
Shift+F10         = DbgUntilLine
Shift+F11         = DbgStepOut
Ctrl+J            = DbgJumpToLine
Ctrl+F3           = AutoFindNext
Shift+F3          = FindPrev
Ctrl+Shift+F3     = AutoFindPrev

Alt+Left          = MarkWord

# Context help keys: they go to a default URL (defined in CtxHelp()
# here in this file) or to CHM help, when the CHM help file is defined in
# the registry at e.g.
# "HKxx\Software\Python\PythonCore\V.v\Help\HelpNumpy" in the same way as
# "HKxx\Software\Python\PythonCore\V.v\Help\Main Python Documentation"
F1               = HelpPy
Ctrl+F1          = HelpPyWin
Alt+F1           = HelpMSDN
Shift+F1         = HelpWXPY
Shift+Alt+F1     = HelpWX

F12              = HelpNumpy
Shift+F12        = HelpScipy
Ctrl+F12         = HelpPandas
Alt+Shift+F12    = HelpSklearn
Ctrl+Shift+F12   = HelpTensorflow

Alt+F12          = HelpGoogle

# reload this or user config
Alt+Shift+R       = ReloadConfig
Alt+M             = DarkMode

[Keys:Editor]
# Key bindings specific to the editor
F2                = GotoNextBookmark
Shift+F2          = GotoPrevBookmark
Ctrl+F2           = ToggleBookmark
Ctrl+G            = GotoLine

# Ctrl+L            = LocateObject  # hardwired in Menu/File/Locate
Ctrl+Shift+L      = LocateObjectEx  # open in extra Editor
Alt+L             = GotoLastPos  # order of creation
Shift+Alt+L       = GotoFollowingPos  # order of creation
Alt+Ctrl+L        = AddLastPos  # add / toggle-remove
Alt+N             = GotoNextPos  # position
Alt+Shift+N       = GotoPrevPos  # position
Ctrl+Home         = GotoStartOfFile  # remember last pos when far
Ctrl+End          = GotoEndOfFile  # remember last pos when far

Alt+I             = ShowInteractiveWindow
Alt-B             = AddBanner # A sample Event defined in this file.

# Block operations
Alt+3             = <<comment-region>>
Ctrl+Q            = <<comment-region>>
Shift+Alt+3       = <<uncomment-region>>
Alt+4             = <<uncomment-region>> # IDLE default.
Alt+5             = <<tabify-region>>
Alt+6             = <<untabify-region>>

# Tabs and other indent features
Back              = <<smart-backspace>>
Ctrl+Shift+T      = <<toggle-tabs>>
Alt+U             = <<change-indentwidth>>
Enter             = EnterKey
Tab               = TabKey
Shift-Tab         = <<dedent-region>>

# Folding
Add               = FoldExpand
Alt+Add           = FoldExpandAll
Shift+Add         = FoldExpandSecondLevel
Subtract          = FoldCollapse
Alt+Subtract      = FoldCollapseAll
Shift+Subtract    = FoldCollapseSecondLevel
Multiply          = FoldTopLevel

# Interact with selected lines
Ctrl+Enter        = InteractSelectedLines
Ctrl+Shift+Enter  = ExecSelectedLines

[Keys:Interactive]
# Key bindings specific to the interactive window.
# History for the interactive window
Ctrl+Up           = <<history-previous>>
Ctrl+Down         = <<history-next>>
Enter             = ProcessEnter
Ctrl+Enter        = DebugStatement
Shift+Enter       = EnterIndent
Esc               = ProcessEsc
##Back              = ProcessBack # doesn't stop auto-complete show when hitting dot again
Back              = <<smart-backspace>>  # doesn't stop auto-complete show + more
Alt+I             = WindowBack # Toggle back to previous window.
Home              = InteractiveHome # A sample Event defined in this file.
Shift+Home        = InteractiveHomeExtend # A sample Event defined in this file.

# When docked, the Ctrl+Tab and Shift+Ctrl+Tab keys dont work as expected.
Ctrl+Tab          = MDINext
Ctrl+Shift+Tab    = MDIPrev

[Extensions]
# Python event handlers specific to this config file.
# All functions not starting with an "_" are assumed
# to be events, and take 2 params:
# * editor_window is the same object passed to IDLE
#   extensions.  editor_window.text is a text widget
#   that conforms to the Tk text widget interface.
# * event is the event being fired.  Will always be None
#   in the current implementation.

# Simply by defining these functions, they are available as
# events.
# Note that we bind keystrokes to these events in the various
# [Keys] sections.

# Note: This code executed from config.py/ConfigManager.configure
# via SyntEditView.OnInitialUpdate > ... > DoConfigChange
# upon EACH creation of a new editor view.
# Its (re-)compiled upon import/reload of pywin.scintilla.view

# Add a simple file/class/function simple banner
def AddBanner(editor_window, event):

	text = editor_window.text
	big_line = "#" * 70
	banner = "%s\n## \n## \n## \n%s\n" % (big_line, big_line)

	# Insert at the start of the current line.
	pos = text.index("insert linestart")

	text.undo_block_start() # Allow action to be undone as a single unit.
	text.insert(pos, banner)
	text.undo_block_stop()

	# Now set the insert point to the middle of the banner.
	line, col = [int(s) for s in pos.split(".")]
	text.mark_set("insert", "%d.1 lineend" % (line+2, ) )


# Here is a sample event bound to the "Home" key in the
# interactive window
def InteractiveHome(editor_window, event):
	return _DoInteractiveHome(editor_window.text, 0)

def InteractiveHomeExtend(editor_window, event):
	return _DoInteractiveHome(editor_window.text, 1)

def _DoInteractiveHome(text, extend):
	import sys
	# If Scintilla has an autocomplete window open, then let Scintilla handle it.
	if text.edit.SCIAutoCActive():
		return 1
	of_interest = "insert linestart + %d c" % len(sys.ps1)
	if not text.compare("insert", "==", of_interest) and \
	   text.get("insert linestart", of_interest) in [sys.ps1, sys.ps2]: # Not sys.ps? line
		end = of_interest
	else:
		end = "insert linestart"

	if extend: start = "insert"
	else: start = end
	text.tag_add("sel", start, end)

# From Niki Spahie
def AutoFindPrev(editor_window, event):
    return AutoFindNext(editor_window, event, prev=True)
def AutoFindNext(editor_window, event, prev=False):
    "find selected text or word under cursor"

    from pywin.scintilla import find
    from pywin.scintilla import scintillacon

    try:
        sci = editor_window.edit
        word = sci.GetSelText()
        if word:
            find.lastSearch.findText = word
            find.lastSearch.sel = sci.GetSel()
        else:
            pos = sci.SendScintilla( scintillacon.SCI_GETCURRENTPOS )
            start = sci.SendScintilla( scintillacon.SCI_WORDSTARTPOSITION, pos, 1 )
            end = sci.SendScintilla( scintillacon.SCI_WORDENDPOSITION, pos, 1 )
            word = sci.GetTextRange( start, end )
            if word:
                find.lastSearch.findText = word
                find.lastSearch.sel = (start,end)
    except Exception:
        import traceback
        traceback.print_exc()
    if prev:
        FindPrev(editor_window, event)
    else:
        find.FindNext()

def FindPrev(editor_window, event=None):
    "find selected text or word under cursor"
    from pywin.scintilla import find
    sci = editor_window.edit
    a, b = sci.GetSel()
    rgn_end = max(a, b) - 1
    # do like find.FindNext()
    params = find.SearchParams(find.lastSearch)
    params.sel = (rgn_end, 0)   # -> search in reverse direction
    if not params.findText:
        ShowFindDialog()
    else:
        return find._FindIt(sci, params)

# A couple of generic events.
def Beep(editor_window, event):
	editor_window.text.beep()

def DoNothing(editor_window, event):
	pass

def ContinueEvent(editor_window, event):
	# Almost an "unbind" - allows Pythonwin/MFC to handle the keystroke
	return 1

# Context Help (F1 and related keys in the editor at a word)

_help_table = {
	# doc_id : registry_CHM_help_name (None->doc_id), CHM_index_template, URL_template
	'HelpPy' : ('Main Python Documentation', '%s', 'http://www.google.com/search?q=python+%s'),  # F1
	'HelpPyWin' : ("Pythonwin Reference", '%s', 'http://www.google.com/search?q=pywin32+%s'), # Ctrl+F1
	'HelpMSDN' : (None, '%s', 'http://social.msdn.microsoft.com/Search/en-US/?Query=%s'), # Alt+F1
	'HelpWXPY' : (None, '%s', 'https://docs.wxpython.org/search.html?q=%s&check_keywords=yes'), # Shift+F1
	'HelpWX'  : (None, 'wx%s', 'https://docs.wxwidgets.org/trunk/search.php?query=wx%s'), # Shift+Alt+F1

	'HelpNumpy' : (None, '%s', 'https://numpy.org/doc/stable/search.html?q=%s&check_keywords=yes'), # F12
	'HelpScipy' : (None, '%s', 'https://docs.scipy.org/doc/scipy/reference/search.html?q=%s&check_keywords=yes'), # Shift+F12
	'HelpPandas' : (None, '%s', 'https://pandas.pydata.org/pandas-docs/stable/search.html?q=%s'),  # Ctrl+F12
	'HelpSklearn' : (None, '%s', 'https://scikit-learn.org/stable/search.html?q=%s'), # Alt+Shift+F12
	'HelpTensorflow' : (None, '%s', 'https://www.tensorflow.org/s/results?q=%s'),  # Ctrl+Shift+F12

	'HelpGoogle' : (None, '%s', 'https://www.google.com/search?q=%s'), # Alt+F12
	}
for _k in _help_table:
	exec("def %s(ed, event): CtxHelp(ed, event)" % _k)

def CtxHelp(editor_window, event=None, return_word=False, hf_url=None):
	"""launch context sensitive help for relevant word near cursor position
	"""
	import sys, os, re, pywin, traceback
	
	self = editor_window.edit
	
	start, end = self.GetSel()
	if start != end:
		word = self.GetSelText()
	else:
		# find the relevant word at or left of cursor ..
		iline = self.LineFromChar(start)
		linestart = self.LineIndex(iline)
		line = self.GetLine(iline)
		curpos = start - linestart
		word = ''
		for m in re.finditer(r'\b[A-Za-z_]\w+', line):   # min 2 lettered words
			if m.start() > curpos:
				break
			w = m.group()
			if w in ('self', 'this',  'and', 'or', 'not', 'in', 'if', 'else', 'None'):
			## if keyword.iskeyword(w):
				continue   # ignore names too trivial & frequently near symbols
			word = w
			start, end = m.start() + linestart, m.end() + linestart

	if return_word:
		return word, start, end

	if not word:
		return
	
	import win32help, regutil, win32ui, webbrowser
	PY3 = sys.version_info[0] > 2
	if PY3: from urllib.parse import quote
	else:   from urllib       import quote            
	
	hwnd = None
	hstr = PY3 and (lambda x:x) or (lambda x:x.encode('mbcs'))
	
	doc_id = sys._getframe(1).f_code.co_name  # caller name, e.g. 'HelpPyWin'
	if not hf_url:
		hf_url = _help_table.get(doc_id)
	if not hf_url:
		sys.stdout.write("-- default.cfg/CtxHelp(): unknown help doc_id %s --\r\n" % doc_id)
		return
	hf_name, hf_template, url_template = hf_url
	hf = regutil.GetRegisteredHelpFile(hf_name or doc_id)  
	if hf:
		win32help.HtmlHelp(hwnd, hf, win32help.HH_DISPLAY_INDEX, hstr(hf_template % word))
	else:
		webbrowser.open(url_template % (word))                                                

def MarkWord(editor_window, event):
	word, start, end = CtxHelp(editor_window, return_word=True)
	if word:
		editor_window.edit.SetSel(start, end)

def InteractSelectedLines(editor_window, event):
	ExecSelectedLines(editor_window,event, mode='interact')
def ExecSelectedLines(editor_window, event, mode=''):
	"""Execute selected lines in global namespace (auto-unindented)"""
	import sys, string, re, pywin
	write = sys.stdout.write
	
	self = editor_window.edit
	startpos, endpos = self.GetSel()
	if endpos > startpos: 
		endpos = endpos - 1
	start, end = map(self.LineFromChar, (startpos, endpos))
	code=''

	# get selected lines & compute minimal leading whitespace
	l = []          # accumulated lines
	baselines = 1   # counts lines which have minimal leading whitespace
	minw = 0        # minimal leading whitespace of the lines
	if start == end and startpos != endpos:
		l = [self.GetSelText().lstrip()]
	else:
		minw = 10000
		linecount = self.GetLineCount()
		for i in range(start, end + 1):
			line = self.GetLine(i)
			white = len(line) - len(line.lstrip())
			if white < minw:
				minw = white
				baselines = 1
			elif white == minw:
				baselines += baselines + 1
			l.append(line)

		# fetch indented lines of open statments (todo: use interpreter intelligence)
		if line.strip().endswith(':'): 
			white1 = len(line) - len(line.lstrip())
			while i < linecount:
				i = i+1
				line = self.GetLine(i)
				xline = line.lstrip()
				if not xline or xline.startswith('#'):
					continue
				white = len(line) - len(xline)
				if white == minw and sum([xline.startswith(x)
										  for x in ('else:','except:','finally:')]): # sum='any'
					pass
				elif white <= minw:
					break
				l.append(line)

	# print first to last line when executing snippet 
	if mode != 'interact':
		write('\r\n' + sys.ps2)
		write(re.sub('\r|\n', '', l[0][minw:]) + '\r\n')
		if len(l) > 1:
			if len(l) > 2:
				write('..\r\n')
			write(sys.ps2 + re.sub('\r|\n', '', l[-1][minw:]) + '\r\n')

	# .. or put snippet lines for interaction
	i = 0
	if mode == 'interact' and baselines > 1:
		write('\r\n' + sys.ps2 + 'if 1:')
	for line in l:
		code = code + line[minw:]
		if mode == 'interact':
			write('\r\n' + sys.ps2)
			if baselines > 1:
				write('    ')  # indent of "if 1:"
			write(re.sub('\r|\n', '', line[minw:]))
		i = i + 1

	from pywin.framework import interact
	interact.edit.currentView.SetSel(-1)
	if mode == 'interact':
		interact.ShowInteractiveWindow()
		return 0

	#execute snippet lines  
	write('-- executing lines in interactive context ... --\r\n')
	interp = interact.edit.currentView.interp
	try:
		exec(code.replace('\r\n', '\n'), interp.globals, interp.locals)
		if interp.curframe:
			 # transfer locals dict -> fast locals
			interact.save_locals(interp.curframe)
	except:
		import traceback
		traceback.print_exc()
	write('-- lines executed --\n' + sys.ps1)
	return 0

# toggles between 4 dark / light modes (Alt-M)
def DarkMode(editor_window, event):
	import sys, win32ui, win32con, pywin.scintilla.formatter
	mask = pywin.scintilla.formatter.FormatterBase.SetDarkMode(None)
	l = [0, 0xE5E5E5, 0xFFFFFF, 0x10000000, 0x1f1818]
	try: i = l.index(mask) + 1
	except ValueError: i = 0
	mask = pywin.scintilla.formatter.FormatterBase.SetDarkMode(l[i  % len(l)])
	##sys.stdout.write("-- DarkMode toggled: pywin.scintilla.formatter.FormatterBase.SetDarkMode(0x%X)\n" % mask)

def ReloadConfig(editor_window, event):
	# note: similarly by Opening & OK of PythonWin options dialog
	import sys, win32ui, win32con, pywin.scintilla.view
	pywin.scintilla.view.LoadConfiguration()
	win32ui.GetMainFrame().SendMessageToDescendants(win32con.WM_WININICHANGE, 0, 0)
	sys.stdout.write("-- ReloadConfig done.\n")
	
